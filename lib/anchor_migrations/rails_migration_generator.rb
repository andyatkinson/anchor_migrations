# frozen_string_literal: true

module AnchorMigrations
  # Create a Rails migration from Anchor Migration SQL
  class RailsMigrationGenerator
    def initialize(migrations_dir: "anchor_migrations")
      @migrations_dir = migrations_dir
      @migration_file_suffix = nil
      # TODO: only supports one migration file at a time
      @anchor_migration_file = Dir["#{@migrations_dir}/*.sql"].max
      @migration_version = File.basename(@anchor_migration_file).split("_").first
      sql_ddl = File.read(@anchor_migration_file)
      cleaned_sql = AnchorMigrations::Utility.cleaned_sql(sql_ddl)
      @sql_ddl = cleaned_sql
      parse_sql_ddl
    end

    # TODO handle missing migrations dir
    # handle missing migration file
    def generate(write_file: true)
      # TODO: add more operation types
      # - create index
      # - drop index
      return unless @sql_ddl =~ /create index|drop index/i

      output_file = "#{migrations_dir}/#{@migration_version}_#{@migration_file_suffix}.rb"
      migration_content = rails_generate_migration_code
      if write_file
        File.write(output_file, migration_content)
        puts "Wrote file: #{output_file}"
        puts File.read(output_file)
      end
      migration_content
    end

    private

    def migrations_dir
      subdirs = %w[db migrate]
      File.join(subdirs)
    end

    def rails_version_major_minor
      AnchorMigrations::RailsLoader.load_rails!

      if defined?(Rails) && defined?(Rails::VERSION)
        major = Rails::VERSION::MAJOR
        minor = Rails::VERSION::MINOR
        "#{major}.#{minor}"
      else
        "X.Y" # can't load Rails
      end
    end

    # Try and deduce the operation type
    # TODO add more operation types
    # NOTE: Using named capture groups
    def parse_sql_ddl
      # Replace inner \n with empty space
      # Strip trailing \n
      @sql_ddl = @sql_ddl.gsub("\n",' ').strip
      # Case-insensitive regex with optional keywords

      if @sql_ddl =~ /(?<ddl>create\s+index # "CREATE INDEX"
        |drop\s+index)                      # "DROP INDEX"
        \s+concurrently                     # required "concurrently"
        \s+(if\s+not\s+exists|if\s+exists)  # "if not exists" or "if exists"
        \s+(?<idx>\w+)                      # index name (non-whitespace)
      /xi
        @index_name = Regexp.last_match(:idx)
        index_name_mig_name = @index_name.split("_").map(&:capitalize).join
        ddl_type = Regexp.last_match(:ddl)
        ddl_type_mig_name = ddl_type.split.map(&:capitalize).join
        ddl_type_file_name = ddl_type.split.map(&:downcase).join("_")
        @migration_file_suffix = "#{ddl_type_file_name}_#{@index_name}"
        @migration_name = "#{ddl_type_mig_name}#{index_name_mig_name}"
      end
    end

    # Assume it's a concurrently operation for now, disable_ddl_transaction!
    # TODO: support strong_migrations
    def rails_generate_migration_code
      sql_ddl = @sql_ddl
      if AnchorMigrations.configuration.use_strong_migrations
        sql_ddl = <<-WITH_SM
        safety_assured do
          #{sql_ddl}
        end
        WITH_SM
      end

      <<~MIG_TEMPLATE.strip
        #
        # ################################################
        # DO NOT EDIT, generated by Anchor Migrations
        # Version: #{@migration_version}
        # File: #{@anchor_migration_file}
        # ################################################
        #
        class #{@migration_name} < ActiveRecord::Migration[#{rails_version_major_minor}]
          disable_ddl_transaction!

          def change
            execute <<-SQL
              #{sql_ddl}
            SQL
          end
        end
      MIG_TEMPLATE
    end
  end
end
