# frozen_string_literal: true

module AnchorMigrations
  class RailsMigrationGenerator
    def initialize
      @migration_file_suffix = nil
      # TODO: only supports one migration at a time
      # TODO check that there aren't more than one unapplied migration
      @anchor_migration_file = Dir["anchor_migrations/*.sql"].max
      @migration_version = File.basename(@anchor_migration_file).split("_").first
      sql_ddl = File.read(@anchor_migration_file)
      cleaned_sql = AnchorMigrations::Utility.cleaned_sql(sql_ddl)
      @sql_ddl = cleaned_sql
      parse_sql_ddl
    end

    def generate
      # TODO: add more operation types
      return unless @sql_ddl =~ /create index/i

      output_file = "#{migrations_dir}/#{@migration_version}_#{@migration_file_suffix}.rb"
      File.write(output_file, rails_generate_migration_code)
      puts "Wrote file: #{output_file}"
      puts File.read(output_file)
    end

    private

    def migrations_dir
      subdirs = %w[db migrate]
      File.join(subdirs)
    end

    def get_rails_version
      AnchorMigrations::RailsLoader.load_rails!

      if defined?(Rails) && defined?(Rails::VERSION)
        major = Rails::VERSION::MAJOR
        minor = Rails::VERSION::MINOR
        "#{major}.#{minor}"
      else
        "X.Y" # can't load Rails
      end
    end

    # Try and deduce the operation type
    # TODO add more operation types, only supporting CREATE INDEX for now
    def parse_sql_ddl
      # Case-insensitive regex with optional keywords
      if @sql_ddl =~ /create\s+index          # "create index" keywords
        \s+concurrently         # required "concurrently"
        \s+if\s+not\s+exists    # required "if not exists"
        \s+(\S+)                # capture index name (non-whitespace)
        \s+on\s+                # "on" keyword
      /xi
        @index_name = ::Regexp.last_match(1)
        migration_name_from_index = @index_name.split("_").map(&:capitalize).join
        @migration_file_suffix = "create_index_#{@index_name}"
        @migration_name = "CreateIndex#{migration_name_from_index}"
      end
    end

    # Assume it's a concurrently operation for now, disable_ddl_transaction!
    # TODO: support strong_migrations
    def rails_generate_migration_code
      <<~MIG_TEMPLATE.strip
        #
        # ################################################
        # DO NOT EDIT, generated by Anchor Migrations
        # Version: #{@migration_version}
        # File: #{@anchor_migration_file}
        # ################################################
        #
        class #{@migration_name} < ActiveRecord::Migration[#{get_rails_version}]
          disable_ddl_transaction!

          def change
            execute <<-SQL
              #{@sql_ddl}
            SQL
          end
        end
      MIG_TEMPLATE
    end
  end
end
