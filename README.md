# âš“ Anchor Migrations
Anchor Migrations are SQL DDL, non-blocking, idempotent, and augment the normal ORM migrations process.

## Commands
```sh
anchor init         # initialize directories
anchor generate     # generate an empty versioned .sql file, to be filled in
anchor lint         # safety-lint all .sql files using Squawk
anchor backfill     # Backfill a Rails migration from the SQL
anchor migrate      # Run the Anchor Migration DDL
```

## Installation
Add `anchor_migrations` to your `development` group Gemfile
```rb
group :development do
  gem 'anchor_migrations'
end
```
Then run `bundle install`.

## Preconditions
Anchor Migrations are restricted and opinionated for now, expecting a few things:
- Postgres only, 13+
- `DATABASE_URL` environment variable is set to the database to migrate (e.g. production), and is reachable, in order to apply migrations
- The `psql` client can be reached by the gem
- The [Squawk](https://squawkhq.com) executable is installed and reachable for use

## Safety linting and lock_timeout
Squawk is used on SQL migrations to check for unsafe operations. For example, creating an index or dropping an index without using CONCURRENTLY is detected by Squak. Anchor Migrations will require safety-linted SQL, although right now itâ€™s up to the developer to run `anchor lint` in their workflow.

When Anchor Migration SQL is ready to apply, a psql client connection is used for that. By default a 2 second `lock_timeout`[^docs] is set.

## What problems do Anchor migrations solve?
1. Anchor Migrations are an additional mechanism to release safe DDL changes that donâ€™t have code dependencies, while keeping all databases in sync using ORM migrations.

Anchor Migrations are a process for organizations not using [Trunk Based Development](https://trunkbaseddevelopment.com) (TBD) or frequent releases, to allow safe DDL to get released more frequently.

Because Anchor Migrations generate the ORM (Active Record) migration *from* the SQL, Rails migrations stay in sync.

## Example Anchor Migration SQL
By default, Anchor Migrations are stored in `db/anchor_migrations` as `.sql` files:
```sql
-- anchor_migrations/20250623173850_anchor_migration.sql
CREATE INDEX CONCURRENTLY IF NOT EXISTS
idx_trips_created_at ON trips (created_at);
```

Squawk runs on the SQL file above for "safety linting", looking for unsafe patterns.

Run it using anchor migrations with the `lint` command:
```sh
~/app âžœ bundle exec anchor lint

Found 0 issues in 1 file ðŸŽ‰
```

## Example ORM (Active Record) Migration
This Rails migration was generated from the Anchor Migration SQL file above.

For this example, Strong Migrations is used, so the `safety_assured` block it expects is added to the Rails migration.
```rb
#
# ################################################
# DO NOT EDIT, generated by Anchor Migrations
# Version: 20250623173850
# File: anchor_migrations/20250623173850_anchor_migration.sql
# ################################################
#
class CreateIndexIdxTripsCreatedAt < ActiveRecord::Migration[7.2]
  disable_ddl_transaction!

  def change
    safety_assured do
      execute <<-SQL
        CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_trips_created_at ON trips (created_at);
      SQL
    end
  end
end
```

## Configuration
Currently, limited configuration is supported.

Anchor Migrations supports generating Strong Migrations-compatible Active Record migrations:
```rb
# config/initializers/anchor_migrations.rb
AnchorMigrations.configure do |config|
  config.use_strong_migrations = true
end
```

## Example PR Workflow
For a PR, add:
1. The Anchor Migration SQL file.
1. The normal Rails migration files: Run `db:migrate` like normal to apply the migration. The developer submits the migration file and the diff to `db/structure.sql` or `db/schema.rb` like they normally would.
1. Get an "approval" describing your plans to run `bundle exec anchor migrate`. The approval can be a comment in the PR from a team member.
1. With an approval, run `anchor migrate` and capture the output (see below). Once applied, move the SQL migration into `db/anchor_migrations/applied` and update your PR.
1. Get PR approval and merge it in. The Rails migration "backfills" the DDL, applying it wherever it's needed.

Example output of `bundle exec anchor migrate`:
```
Applying Version: 20250623173850
CREATE INDEX CONCURRENTLY IF NOT EXISTS
idx_trips_created_at ON trips (created_at);
STDOUT:
CREATE INDEX
STDERR:
Success!
Applied Version: 20250623173850
Exit code: 0
```
The idempotent Rails migration applies anywhere it's needed and the Rails app is deployed. Other developer databases, lower environments, CI, etc. When it reaches production, the Anchor Migration SQL DDL was already applied, so nothing happens. The Rails migration is idempotent.

## Good uses of Anchor Migrations
### Query support, data integrity, data quality
Indexes (and eventually constraints) that support query performance or data integrity, but have no code dependencies, can be changed at a faster cadence, while keeping everything consistent.

Indexes and constraints improve performance and data quality, and arguably shouldnâ€™t be "blocked" by needing to wait for ORM migrations.

### Long running DDL changes
On large tables, creating indexes concurrently can take a long time. It's nice to perform that during a low activity period, requiring control over the timing, which isn't always possible with ORM migrations.

## Anchor Migrations Properties
### Idempotent
Anchor Migrations in SQL must be written using idempotent tactics like `IF NOT EXISTS`.

This allows the SQL to be the backfill source for an Active Record migration, which is then also idempotent.

### Restricted DDL: What DDL is supported for Anchor Migrations?
Only non-blocking, idempotent DDL is supported. This list is restricted heavily now although additional DDL types may be added in the future:
1. `CREATE INDEX CONCURRENTLY IF NOT EXISTS`
1. `DROP INDEX CONCURRENTLY IF EXISTS` (Postgres 13+)

Roadmap operations, future gem releases:
1. `ALTER TABLE ALTER COLUMN IF NOT EXISTS` (only `NULL` values)
1. Add check constraint, initially not valid

### Uses psql
For now, Anchor Migrations assumes you're using psql to migrate, and that psql can connect to your target instance.

### Whatâ€™s out of scope for Anchor Migrations?
Anchor Migrations are non-blocking and idempotent.

For destructive operations like table drops, column drops, etc. with code dependencies, Anchor Migrations are not appropriate.

That's because application code references need to be removed first.

Use Strong Migrations or similar to help guide that process, and use regular Rails migrations.

Some of those destructive operations are:
1. `DROP TABLE`
1. Adding non-nullable column, or a column with a default value
1. Dropping constraints
1. Adding initially valid constraints
1. Add indexes without using concurrently

[^docs]: <https://www.postgresql.org/docs/current/runtime-config-client.html>

## Building the gem
```sh
gem build anchor_migrations.gemspec
gem install ./anchor_migrations-0.1.0.gem
anchor help
```

## Testing in Rails
Add to Gemfile, run `bundle`.
```sh
bundle exec anchor help
```
