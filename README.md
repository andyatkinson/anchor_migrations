# âš“ Anchor Migrations
Anchor Migrations are SQL DDL, non-blocking, idempotent, and augment the normal ORM migrations process.

## Commands
```sh
anchor init         # initialize directories
anchor generate     # generate an empty versioned .sql file, to be filled in
anchor lint         # safety-lint all .sql files using Squawk
anchor backfill     # Backfill a Rails migration from the SQL
anchor migrate      # Run the Anchor Migration DDL
```

## Installation
Add `anchor_migrations` to your `development` group Gemfile
```rb
group :development do
  gem 'anchor_migrations'
end
```
Then run `bundle install`.

## Preconditions
Anchor Migrations are restricted and opinionated for now, expecting a few things:
- Postgres only, 13+
- `DATABASE_URL` environment variable is set to the database to migrate (e.g. production), and is reachable, in order to apply migrations
- The `psql` client can be reached by the gem
- The [Squawk](https://squawkhq.com) executable is installed and reachable for use

## Safety linting and lock_timeout
Squawk is used on SQL migrations to check for unsafe operations. For example, creating an index or dropping an index without using CONCURRENTLY is detected by Squak. Anchor Migrations will require safety-linted SQL, although right now itâ€™s up to the developer to run `anchor lint` in their workflow.

When Anchor Migration SQL is ready to apply, a psql client connection is used for that. By default a 2 second `lock_timeout`[^docs] is set.

## What problems do Anchor migrations solve?
1. Anchor Migrations are an additional mechanism to release safe DDL changes that donâ€™t have code dependencies, while keeping all databases in sync using ORM migrations.

Anchor Migrations are a process for organizations not using [Trunk Based Development](https://trunkbaseddevelopment.com) (TBD) or infrequent releases, to allow safe DDL to get released more regularly.

Because Anchor Migrations generate the ORM (Active Record) migration *from* the SQL, thereâ€™s no loss of fidelity in the normal ORM migration process. 

## Example Anchor Migration SQL
By default, Anchor Migrations are stored in `anchor_migrations` as `.sql` files:
```sql
-- anchor_migrations/20250623173850_anchor_migration.sql
CREATE INDEX CONCURRENTLY IF NOT EXISTS
idx_trips_created_at ON trips (created_at);
```

Squawk runs on the file above for "safety linting":
```sh
~/app âžœ bundle exec anchor lint

Found 0 issues in 1 file ðŸŽ‰
```

## Example ORM (Active Record) Migration
This Rails migration was generated from the SQL above.

This example was generated after enabling Strong Migrations, a configuration option.

```rb
#
# ################################################
# DO NOT EDIT, generated by Anchor Migrations
# Version: 20250623173850
# File: anchor_migrations/20250623173850_anchor_migration.sql
# ################################################
#
class CreateIndexIdxTripsCreatedAt < ActiveRecord::Migration[7.2]
  disable_ddl_transaction!

  def change
    safety_assured do
      execute <<-SQL
        CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_trips_created_at ON trips (created_at);
      SQL
    end
  end
end
```

## Configuration
Currently, limited configuration is supported.

Anchor Migrations can generate Strong Migrations compatible Active Record, by adding this block:
```rb
# config/initializers/anchor_migrations.rb
AnchorMigrations.configure do |config|
  config.use_strong_migrations = true
end
```

## Preparing a PR
For a PR, add:
1. The Anchor Migration SQL file.
1. The normal Rails migration files: Run `db:migrate` like normal to apply it. The developer submits the migration file and the diff to `db/structure.sql` or `db/schema.rb` like they normally would.

That's it. It's mainly one additional SQL file.

Once the PR is approved containing these files, the developer can run `bundle exec anchor migrate` to apply the DDL. The applied migration can be recorded, and the PR merged.

For example, capture the output of running `bundle exec anchor migrate`:
```
Applying Version: 20250623173850
CREATE INDEX CONCURRENTLY IF NOT EXISTS
idx_trips_created_at ON trips (created_at);
STDOUT:
CREATE INDEX
STDERR:
Success!
Applied Version: 20250623173850
Exit code: 0
```

The idempotent Rails migration applies anywhere in lower environments, and does not apply when it reaches production, where the Anchor Migration already applied the equivalent SQL DDL.

## Why Use Anchor Migrations?
### Query support, data integrity, data quality
Indexes (and eventually constraints) that support query performance or data integrity, but have no code dependencies, can be changed at a faster cadence, while keeping everything consistent.

Indexes and constraints improve performance and data quality, and arguably shouldnâ€™t be "blocked" by needing to wait for ORM migrations.

### Long running DDL changes
On large tables, creating indexes concurrently can take a long time. It's nice to perform that during a low activity period, requiring control over the timing, which isn't always possible with ORM migrations.

## Anchor Migrations Properties
### Idempotent
Anchor Migrations in SQL must be written using idempotent tactics like `IF NOT EXISTS`.

This allows the SQL to be the backfill source for an Active Record migration, which is then also idempotent.

### Restricted DDL: What DDL is supported for Anchor Migrations?
Only non-blocking, idempotent DDL is supported. This list is restricted heavily now although additional DDL types may be added in the future:
1. `CREATE INDEX CONCURRENTLY IF NOT EXISTS`
1. `DROP INDEX CONCURRENTLY IF EXISTS` (Postgres 13+)

Roadmap operations, future gem releases:
1. `ALTER TABLE ALTER COLUMN IF NOT EXISTS` (only `NULL` values)
1. Add check constraint, initially not valid

### Whatâ€™s out of scope for Anchor Migrations?
Anchor Migrations are non-blocking and idempotent.

For destructive operations like table drops, column drops, etc. with code dependencies, Anchor Migrations are not appropriate.

That's because application code references need to be removed first.

Use Strong Migrations or similar to help guide that process.

Some of those operations are:
1. `DROP TABLE`
1. Adding non-nullable column, or a column with a default value
1. Dropping constraints
1. Adding initially valid constraints
1. Add indexes without using concurrently

[^docs]: <https://www.postgresql.org/docs/current/runtime-config-client.html>

## Building
```sh
gem build anchor_migrations.gemspec
gem install ./anchor_migrations-0.1.0.gem
anchor help
```

## Testing in Rails
```sh
bundle exec anchor help
```
